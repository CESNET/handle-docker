#!/usr/bin/expect -f
#
# This Expect script was generated by autoexpect on Thu Jan 30 18:31:36 2020
# Expect and autoexpect were both written by Don Libes, NIST.
#
# Note that autoexpect does not guarantee a working script.  It
# necessarily has to guess about certain things.  Two reasons a script
# might fail are:
#
# 1) timing - A surprising number of programs (rn, ksh, zsh, telnet,
# etc.) and devices discard or ignore keystrokes that arrive "too
# quickly" after prompts.  If you find your new script hanging up at
# one spot, try adding a short sleep just before the previous send.
# Setting "force_conservative" to 1 (see below) makes Expect do this
# automatically - pausing briefly before sending each character.  This
# pacifies every program I know of.  The -c flag makes the script do
# this in the first place.  The -C flag allows you to define a
# character to toggle this mode off and on.

set force_conservative 0  ;# set to 1 to force conservative mode even if
			  ;# script wasn't run conservatively originally
if {$force_conservative} {
	set send_slow {1 .1}
	proc send {ignore arg} {
		sleep .1
		exp_send -s -- $arg
	}
}

#
# 2) differing output - Some programs produce different output each time
# they run.  The "date" command is an obvious example.  Another is
# ftp, if it produces throughput statistics at the end of a file
# transfer.  If this causes a problem, delete these patterns or replace
# them with wildcards.  An alternative is to use the -p flag (for
# "prompt") which makes Expect only look for the last line of output
# (i.e., the prompt).  The -P flag allows you to define a character to
# toggle this mode off and on.
#
# Read the man page for more info.
#
# -Don


set timeout -1
spawn ./bin/hdl-setup-server {{ .Env.SRV_DIR }}
match_max 100000
expect -exact "\r
To configure your new Handle server, please answer\r
the questions which follow; default answers, shown in \r
\[square brackets\] when available, can be chosen by \r
pressing Enter.\r
\r
\r
Will this be a \"primary\" server (ie, not a mirror of another server)?(y/n) \[y\]: "
send -- "\r"
expect -exact "\r
\r
Will this be a dual-stack server (accessible on both IPv6 and IPv4)?(y/n) \[n\]: "
send -- "\r"
expect -re {.*Through what network-accessible IP address should clients connect to this server.*}
send -- "0.0.0.0\r"
expect -re {.*If different, enter the IP address to which the server should bind.*}
send -- "0.0.0.0\r"
expect -re {.*Enter the .* port number this server will listen to.*}
send -- "{{ .Env.CLIENT_PORT }}\r"
expect -re {.*What port number will the HTTP interface be listening to.*}
send -- "{{ .Env.HTTP_PORT }}\r"
expect -re {.*Would you like to log all accesses to this server.*}
send -- "\r"
expect -exact "\r
\r
Please indicate whether log files should be automatically\r
rotated, and if so, how often.\r
\r
(\"N\" (Never), \"M\" (Monthly), \"W\" (Weekly), or \"D\" (Daily))? \[Monthly\] : "
send -- "D\r"
expect -exact "D\r
\r
Each handle site has a version/serial number assigned\r
to it.  This is so that a client can tell if a particular\r
site's configuration has changed since the last time it\r
accessed a server in the site.  Every time you modify a site\r
(by changing an IP address, port, or adding a server, etc), \r
you should increment the version/serial number for that site.\r
\r
Enter the version/serial number of this site \[1\]: "
send -- "{{ .Env.SITE_VERSION }}\r"
expect -re {.*Please enter a short description of this server/site:.*}
send -- "{{ .Env.SITE_DESCRIPTION}}\r"
expect -re {.*Please enter the name of your organization.*}
send -- "{{ .Env.SITE_ORG }}\r"
expect -re {.*Please enter the name of a contact person.*}
send -- "{{ .Env.SITE_CONTACT_NAME }}\r"
expect -re {.*Please enter the telephone number of.*}
send -- "{{ .Env.SITE_CONTACT_PHONE }}\r"
expect -re {.*Please enter the email address of.*}
send -- "{{ .Env.SITE_CONTACT }}\r"
expect -re {.*Do you need to disable UDP services.*}
send -- "\r"
expect -exact "\r
\r
Generating keys for: Server Certification\r
\r
The private key that is about to be generated should be stored\r
in an encrypted form on your computer. Encryption of the\r
private key requires that you choose a secret passphrase that\r
will need to be entered whenever the server is started.\r
Note: Your private key may be stored unencrypted if you so choose.\r
Please take all precautions to make sure that only authorized\r
users can read your private key.\r
\r
  Would you like to encrypt your private key?(y/n) \[y\]: "
send -- "\r"
expect -exact "\r
\r
Please enter the private key passphrase for Server Certification: \r
Note: Your passphrase will be displayed as it is entered\r
"
send -- "{{ .Env.CERTIFI_PASSPHRASE }}\r"
expect -re {.*Please re-enter the private key passphrase: \r
Note: Your passphrase will be displayed as it is entered\r}
send -- "{{ .Env.CERTIFI_PASSPHRASE }}\r"
expect -re {.*Would you like to encrypt your private key.*}
send -- "\r"
expect -exact "\r
\r
Please enter the private key passphrase for Administration: \r
Note: Your passphrase will be displayed as it is entered\r
"
send -- "{{ .Env.ADM_PASSPHRASE }}\r"
expect -re {.*Note: Your passphrase will be displayed as it is entered\r}
send -- "{{ .Env.ADM_PASSPHRASE }}\r"
expect eof
